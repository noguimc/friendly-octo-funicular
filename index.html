<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<style>
		* {
			padding: 0;
			margin: 0;
		}

		.mine-sweeping {
			width: 100vw;
			height: 100vh;
			display: flex;
		}

		.mine-sweeping-map {
			position: relative;
			margin: auto;
		}

		.mine-sweeping-map {
			border-collapse: collapse;
		}

		.mine-sweeping-map td {
			width: auto;
			height: auto;
			background-color: #c6c6c6;
			background-size: 100%;
		}

		.mine-sweeping-map .unknown {
			background-image: url(../img/closed.svg?v=3);
		}

		.display-screen-top {
			height: 15px;
			display: flex;
			flex-flow: row;
		}

		.mine-manager {
			margin: auto;
		}

		.display-screen-top div:first-child {
			background-image: url(../img/corner_up_left_2x.png);
			height: 100%;
			background-size: 100% 15px;
			width: 16px;
		}

		.display-screen-top div:nth-child(2) {
			background-image: url(../img/border_hor_2x.png);
			height: 100%;
			background-size: 100% 15px;
			flex: 1;
		}

		.display-screen-top div:nth-child(3) {
			background-image: url(../img/corner_up_right_2x.png);
			height: 100%;
			background-size: 100% 15px;
			width: 16px;
		}

		.display-screen-box {
			height: 44px;
			display: flex;
			flex-flow: row;
		}

		.display-screen-box>div:nth-child(1) {
			background-image: url(../img/border_vert_2x.png);
			height: 100%;
			width: 16px;
			background-size: 100% 16px;
		}

		.display-screen-box>div:nth-child(2) {
			flex: 1;
			background-color: silver;
		}

		.display-screen-box>div:nth-child(3) {
			background-image: url(../img/border_vert_2x.png);
			height: 100%;
			width: 16px;
			background-size: 100% 16px;
		}

		.display-screen-bottom {
			height: 15px;
			display: flex;
			flex-flow: row;
		}

		.display-screen-bottom div:nth-child(1) {
			background-image: url(../img/t_left_2x.png);
			height: 100%;
			width: 16px;
			background-size: 100% 16px;
		}

		.display-screen-bottom div:nth-child(2) {
			background-image: url(../img/border_hor_2x.png);
			height: 100%;
			background-size: 100% 15px;
			flex: 1;
		}

		.display-screen-bottom div:nth-child(3) {
			background-image: url(../img/t_right_2x.png);
			height: 100%;
			background-size: 100% 15px;
			width: 16px;
		}

		.mine-sweeping-box {
			display: flex;
			flex-flow: row;
		}

		.mine-sweeping-box div:nth-child(1) {
			background-image: url(../img/border_vert_2x.png);
			height: 100%;
			width: 16px;
			background-size: 100% 16px;
		}

		.mine-sweeping-box div:nth-child(3) {
			background-image: url(../img/border_vert_2x.png);
			height: 100%;
			width: 16px;
			background-size: 100% 16px;
		}

		.mine-sweeping-bottom {
			height: 15px;
			display: flex;
			flex-flow: row;
		}

		.mine-sweeping-bottom div:nth-child(1) {
			background-image: url(../img/corner_bottom_left_2x.png);
			height: 100%;
			background-size: 100% 15px;
			width: 16px;
		}

		.mine-sweeping-bottom div:nth-child(2) {
			background-image: url(../img/border_hor_2x.png);
			height: 100%;
			background-size: 100% 15px;
			flex: 1;
		}

		.mine-sweeping-bottom div:nth-child(3) {
			background-image: url(../img/corner_bottom_right_2x.png);
			height: 100%;
			background-size: 100% 15px;
			width: 16px;
		}

		.display-screen {
			padding: 4px;
			display: flex;
			flex-flow: row;
			height: 100%;
			box-sizing: border-box;
			justify-content: space-between;
		}

		.display-screen .mine-show {
			width: 66px;
			display: flex;
			background-color: black;
		}

		.mine-show *+* {
			margin-left: 3px;
		}

		.mine-show div {
			background-size: 20px 100%;
			width: 20px;
			background-image: url(../img/d0.svg);
		}

		.display-screen .restart {
			background-image: url(../img/face_unpressed.svg);
			background-size: 36px 36px;
			width: 36px;
		}

		.seconds-show {
			width: 66px;
			display: flex;
			background-color: black;
		}

		.seconds-show *+* {
			margin-left: 3px;
		}

		.seconds-show div {
			background-size: 20px 100%;
			width: 20px;
			background-image: url(../img/d0.svg);
		}
	</style>
	<body>
		<div class="mine-sweeping">
			<div class="mine-manager">
				<div class="display-screen-top">
					<div></div>
					<div></div>
					<div></div>
				</div>
				<div class="display-screen-box">
					<div></div>
					<div class="display-screen">
						<div class="mine-show">
							<div></div>
							<div></div>
							<div></div>
						</div>
						<div class="restart"></div>
						<div class="seconds-show">
							<div></div>
							<div></div>
							<div></div>
						</div>
					</div>
					<div></div>
				</div>
				<div class="display-screen-bottom">
					<div></div>
					<div></div>
					<div></div>
				</div>
				<div class="mine-sweeping-box">
					<div></div>
					<div class="mine-sweeping-map"></div>
					<div></div>
				</div>
				<div class="mine-sweeping-bottom">
					<div></div>
					<div></div>
					<div></div>
				</div>
			</div>
		</div>
	</body>
	<script>
		// 根据当前地雷的位置，计算周围8个位置的地雷数量，这里使用了一个二维数组存储偏移量
		const computeArray = [
			[-1, -1],
			[-1, 0],
			[-1, 1],
			[0, -1],
			[0, 1],
			[1, -1],
			[1, 0],
			[1, 1]
		];
		window.onload = () => {
			init();
		}
		// 开始
		function init() {
			// 扫雷棋盘参数
			const mapParams = {
				widthSize: 30,
				heightSize: 15,
				cellSize: 30,
			}
			// 地雷信息
			const mineParams = {
				// 地雷信息
				mineData: [],
				// 展示数组是否展示对应位置
				showData: [],
				// 地雷个数
				mineNum: 99,
				// 上次点击位置,
				nextClick: [],
				// 标记个数
				markers: 0,
				// 游戏状态
				gameState: true,
				// 游戏开始时间
				gameStartTime: null,
			}
			// 初始化地图
			initMap(mapParams);
			// 初始化地雷
			initMine(mineParams, mapParams);
			// 绘制
			draw(mineParams);
			// 开始游戏
			run(mineParams, mapParams);
			// 点击后重新开始游戏
			document.querySelector('.restart').addEventListener('click', () => {
				restart(mineParams, mapParams);
			});
		}


		/**
		 * @param {Object} mapParams 地图参数
		 */
		function initMap(mapParams) {
			const minSweepingMap = document.querySelector(".mine-sweeping-map");
			const mineManager = document.querySelector(".mine-manager");
			const minSweepingBox = document.querySelector(".mine-sweeping-box");
			minSweepingMap.style.width = `${mapParams.widthSize * mapParams.cellSize}px`;
			minSweepingMap.style.height = `${mapParams.heightSize * mapParams.cellSize}px`;
			minSweepingBox.style.height = `${mapParams.heightSize * mapParams.cellSize}px`;
			mineManager.style.width = `${mapParams.widthSize * mapParams.cellSize + 30}px`;
			let mapHtml = `<table class="mine-sweeping-map" style="width: 100%;height: 100%">`
			for (let i = 0; i < mapParams.heightSize; i++) {
				mapHtml += `<tr>`
				for (let j = 0; j < mapParams.widthSize; j++) {
					mapHtml += `<td class="unknown cell-${i}-${j}"></td>`;
				}
				mapHtml += `</tr>`;
			}
			mapHtml += '</table>';
			minSweepingMap.innerHTML = mapHtml;
		}

		/**
		 * 初始化地雷信息
		 *
		 * @param {Object} mineParams 地雷信息参数对象
		 * @param {Object} mapParams 地图信息参数对象
		 */
		function initMine(mineParams, mapParams) {
			// 获取地雷信息参数对象中的mineData属性，这是一个二维数组，表示地雷的分布情况
			const mineData = mineParams.mineData;
			// 获取地雷信息参数对象中的showData属性，这是一个二维数组，表示当前位置是否展示
			const showData = mineParams.showData;
			// 使用循环初始化扫雷数组，高度和宽度由地图信息参数对象提供
			for (let i = 0; i < mapParams.heightSize; i++) {
				// 使用Array.fill方法将数组填充为0，表示没有地雷
				mineData[i] = new Array(mapParams.widthSize).fill(0);
				// 使用Array.fill方法将数组填充为0，表示不展示对应信息
				showData[i] = new Array(mapParams.widthSize).fill(0);
			}
			// 获取地雷信息参数对象中的mineNum属性，表示需要生成的地雷数量
			let mineNum = mineParams.mineNum;
			// 当需要生成的地雷数量大于0时，执行以下循环
			while (mineNum > 0) {
				// 随机生成一个x和y值，作为地雷的位置，避免数组越界
				let x = parseInt(Math.random() * mapParams.widthSize);
				let y = parseInt(Math.random() * mapParams.heightSize);
				// 判断当前位置是否有地雷，如果有，就跳到下一次循环，重新生成一个位置
				if (mineData[y][x] === -1) {
					continue;
				}
				// 在扫雷数组中标记当前位置为地雷，使用-1表示地雷
				mineData[y][x] = -1;
				// 对每个偏移量进行遍历
				computeArray.forEach(m => {
					// 判断如果为地雷就跳过，同时还需要判断位置是否在地图范围内
					if (y + m[0] < 0 || y + m[0] >= mapParams.heightSize ||
						x + m[1] < 0 || x + m[1] >= mapParams.widthSize ||
						mineData[y + m[0]][x + m[1]] === -1) {
						return;
					}
					// 在扫雷数组中标记周围位置的地雷数量+1,不等于-1就说明不是地雷位置
					mineData[y + m[0]][x + m[1]]++;
				})
				// 地雷生成成功，将需要生成的地雷数量减1
				mineNum--;
			}
		}

		/**
		 * 绘制函数，根据地雷信息在网页上绘制地雷图。
		 * @param {Object} mineParams - 地雷信息对象，包含地雷数据的键值对。
		 */
		function draw(mineParams, mapParams) {
			// 获取地雷数据
			const mineData = mineParams.mineData;
			// 展示数据
			const showData = mineParams.showData;
			const lastClick = mineParams.lastClick;
			// 通过两个嵌套的循环遍历地雷数据
			// 第一个循环遍历每一行
			mineData.forEach((arr, i) => {
				// 第二个循环遍历每一行中的每个地雷
				arr.forEach((item, j) => {
					// 获取对应的地雷元素
					// 使用字符串模板语法 `.cell-${i}-${j}` 来构建选择器，选择具有特定类名的元素
					const cell = document.querySelector(`.cell-${i}-${j}`);
					// 判断当前是否没有被点击
					if (showData[i][j] === 0) {
						cell.style.backgroundImage = 'url(../img/closed.svg?v=3)';
						return;
					}
					// 设置当前为被标记状态
					if (showData[i][j] === 2) {
						cell.style.backgroundImage = 'url(../img/flag.svg)';
						return;
					}
					// 如果地雷类型为 -1，设置背景图像为地雷图
					if (item === -1) {
						cell.style.backgroundImage = 'url(../img/mine.svg?v=3)';
						// 结束当前循环，不再处理后续地雷
						return;
					}
					// 对于其他类型的地雷，设置背景图像为对应类型的地雷图
					cell.style.backgroundImage = `url(../img/type${item}.svg?v=3)`;
				})
			})
			// 游戏结束停止动画
			if (!mineParams.gameState) {
				// 上一次如果是地雷则显示
				if (mineData[lastClick[0]][lastClick[1]] === -1) {
					document.querySelector('.restart').style.backgroundImage = 'url(../img/face_lose.svg)'
					document.querySelector(`.cell-${lastClick[0]}-${lastClick[1]}`).style.backgroundImage =
						'url(../img/mine_red.svg?v=3)';
				} else {
					// 游戏赢了
					alert("恭喜你，赢得了游戏")
				}

				return;
			}
			// 绘制控制面板
			drawDisplayScreen(mineParams);
			requestAnimationFrame(() => draw(mineParams, mapParams));
		}
		/**
		 * 展示当前剩余标记数据和开始时间
		 * @param {Object} mineParams - 标记数量和游戏开始时间的对象
		 */
		function drawDisplayScreen(mineParams) {
			// 获取HTML文档中class为"mine-show"的元素
			const mineShow = document.querySelector(".mine-show");
			// 获取HTML文档中class为"seconds-show"的元素
			const secondsShow = document.querySelector(".seconds-show");
			// 计算剩余的标记的数量
			const remain = mineParams.mineNum - mineParams.markers;
			// 如果游戏开始时间参数存在，则使用游戏开始时间，否则使用当前时间作为开始时间
			const gameStartTime = mineParams.gameStartTime ? mineParams.gameStartTime : new Date().getTime();
			// 计算游戏开始至今的秒数
			const startSeconds = parseInt((new Date().getTime() - gameStartTime) / 1000);
			// 定义一个名为setNums的内部函数，接收两个参数：一个DOM元素(dom)和一个数字(num)
			function setNums(dom, num) {
				// 获取传入的DOM元素的子元素数组
				const children = dom.children;
				// 将每个子元素的背景图片设为预设的图标，为零
				for (let item of children) {
					item.style.backgroundImage = `url(../img/d0.svg)`
				}
				// 将数字转为字符串，并将字符串的每个字符转为对应的数字，用于之后的操作
				num = num + "";
				// 定义一个索引变量，用于之后在子元素数组中查找元素
				let index = 0;
				// 根据数字字符串的每个字符，逐个更改子元素的背景图片
				for (let i = num.length - 1; i >= 0; i--) {
					// 如果子元素数组中的最后一个元素存在
					if (children[children.length - index - 1]) {
						// 将该子元素的背景图片设为对应的数字的预设图标
						children[children.length - index - 1].style.backgroundImage = `url(../img/d${num.charAt(i)}.svg)`
					}
					// 索引加一，用于之后查找下一个子元素
					index++;
				}
			}
			// 对mineShow元素和remain进行调用setNums函数，用于设置显示内容
			setNums(mineShow, remain);
			// 对secondsShow元素和startSeconds进行调用setNums函数，用于设置显示内容
			setNums(secondsShow, startSeconds);
		}

		/**
		 * 运行扫雷游戏
		 *
		 * @param {Object} mineParams - 地雷参数
		 * @param {Object} mapParams - 地图参数
		 */
		function run(mineParams, mapParams) {
			// 获取扫雷地图的元素
			const minSweepingBox = document.querySelector(".mine-sweeping-map");
			// 获取地雷数据
			const mineData = mineParams.mineData;
			// 获取显示数据（可能是用来记录哪些地雷已经显示出来的数据）
			const showData = mineParams.showData;
			/**
			 * 计算附近没有地雷的地方
			 *
			 * @param {Array} offset - 偏移量
			 */
			function setNearbyisZero(offset) {
				// 检查偏移量是否在地图范围内，并且该位置的显示数据为0（即该位置还没有被显示）
				if (offset[0] >= 0 && offset[0] < mapParams.heightSize &&
					offset[1] >= 0 && offset[1] < mapParams.widthSize &&
					showData[offset[0]][offset[1]] === 0) {
					// 如果该位置有地雷，则将其在显示数据中标记为1（已显示）
					if (mineData[offset[0]][offset[1]] !== -1) {
						showData[offset[0]][offset[1]] = 1;
					}
					// 如果该位置的地雷数为0，则递归计算其周围的8个位置
					if (mineData[offset[0]][offset[1]] === 0) {
						computeArray.forEach(m => setNearbyisZero([offset[0] + m[0], offset[1] + m[1]]));
					}
				}
			}

			/**
			 * 点击事件处理函数
			 *
			 * @param {Event} e - 事件对象
			 */
			function clickEventFun(e) {
				// 初始化游戏开始时间
				if (!mineParams.gameStartTime) {
					mineParams.gameStartTime = new Date().getTime();
				}
				// 根据点击位置计算出对应的地图上的坐标
				const x = parseInt((e.clientX - minSweepingBox.offsetLeft) / mapParams.cellSize);
				const y = parseInt((e.clientY - minSweepingBox.offsetTop) / mapParams.cellSize);
				// 如果该位置已经被显示过就直接返回
				if (showData[y][x] === 1 || showData[y][x] === 2) {
					return;
				}
				// 将上一次点击的位置存入参数对象中
				mineParams.lastClick = [y, x];
				// 如果点击的位置有地雷，则游戏结束，并展开所有地雷
				if (mineData[y][x] == -1) {
					// 展开全部地雷，将所有地雷在显示数据中的值设为1（已显示）
					showData.forEach((arr, i) => {
						arr.forEach((item, j) => {
							showData[i][j] = mineData[i][j] === -1 ? 1 : showData[i][j];
						});
					});
					// 移除点击事件监听器，结束游戏
					minSweepingBox.removeEventListener('click', clickEventFun);
					minSweepingBox.removeEventListener('contextmenu', contextmenuFun);
					mineParams.gameState = false;
					return;
				}
				// 如果点击的位置没有地雷，则计算其周围没有地雷的位置，并将其在显示数据中的值设为1（已显示）
				setNearbyisZero([y, x]);
				// 判断这次点击后是不是只剩下地雷如果是则游戏结束，赢得游戏的胜利
				let hasNotMine = false;
				for (let i = 0; i < mineData.length; i++) {
					const arr = mineData[i];
					for (let j = 0; j < arr.length; j++) {
						const item = showData[i][j];
						// 判断未显示的地方不是地雷的
						if (item === 0 && mineData[i][j] !== -1) {
							hasNotMine = true;
							break;
						}
					}
					if (hasNotMine) {
						break;
					}
				}
				// 如果剩下未显示的位置全是地雷,就结束游戏
				if (!hasNotMine) {
					// 移除点击事件监听器，结束游戏
					minSweepingBox.removeEventListener('click', clickEventFun);
					minSweepingBox.removeEventListener('contextmenu', contextmenuFun);
					mineParams.gameState = false;
				}
			}

			/**
			 * 鼠标右键点击事件处理函数
			 *
			 * @param {Event} e - 事件对象
			 */
			function contextmenuFun(e) {
				// 初始化游戏开始时间
				if (!mineParams.gameStartTime) {
					mineParams.gameStartTime = new Date().getTime();
				}
				// 禁止右键的默认点击事件
				e.preventDefault();
				// 根据点击位置计算出对应的地图上的坐标
				const x = parseInt((e.clientX - minSweepingBox.offsetLeft) / mapParams.cellSize);
				const y = parseInt((e.clientY - minSweepingBox.offsetTop) / mapParams.cellSize);
				// 如果该位置已经被显示过就直接返回
				if (showData[y][x] === 1) {
					return;
				}
				// 设置为标记地雷
				showData[y][x] = showData[y][x] === 2 ? 0 : 2;
				// 判断标记数是增加还是减少
				mineParams.markers += showData[y][x] === 2 ? 1 : -1;
			}
			// 监听鼠标左键点击事件
			minSweepingBox.addEventListener('click', clickEventFun);
			// 监听鼠标右键点击事件
			minSweepingBox.addEventListener('contextmenu', contextmenuFun);

		}
		/**
		 * 重新开始游戏，设置初始值
		 * @param {Object} mineParams
		 * @param {Object} mapParams
		 */
		function restart(mineParams, mapParams) {
			mineParams.markers = 0;
			mineParams.gameStartTime = null;
			document.querySelector('.restart').style.backgroundImage = 'url(../img/face_unpressed.svg)'
			// 初始化地雷
			initMine(mineParams, mapParams);
			if (!mineParams.gameState) {
				mineParams.gameState = true;
				draw(mineParams)
				run(mineParams, mapParams);
			}
		}
	</script>
</html>
